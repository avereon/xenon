Use cases:
- Program wants to know the available products in all markets, regardless of channel
  - Program requests a list of unique products in each market
  - The market returns the latest release for each product it hosts
  - The program will need to determine how it will handle products found in multiple markets
    - Usually by finding the latest release for each unique product
- [Check for updates] Program wants to know the latest release of a product, probably by channel
  - The program already knows what market and product to look for, it just needs to know what the latest version is
  - The market returns the product card for the latest release of the product it hosts
  - If the product is no longer hosted in the expected market (HTTP 404) it may inform the user
    - And might find new versions of the product in other markets and also inform the user
- [Stage updates] Program wants to download a specific artifact of a product
  - The program has already determined what it needs to download and asks the market for the specific artifact to download
  - The market returns the product artifact requested, or HTTP 404 if it is not found
- Web site wants to know the available downloads for a product, probably by channel, category(installer) and platform
  - The web site requests a list of the available downloads
    - It might query for all products, products in a channel, channels for a product, artifacts for a product, etc.
  - The market returns a list of product downloads
- Web site wants to download a specific artifact of a product, probably the installer
  - The web site has already determined what it needs to download and asks the market for the specific artifact to download
  - The market returns the product artifact requested, or HTTP 404 if it is not found

Based on the use cases both the client and server could have logic to help the
other. The question now stands, how much logic to put where? There is no
question the client needs some logic to determine what it wants, but should it
also have logic to handle a "dumb" repository? And how "dumb" can the
repository be before it becomes a problem? How much burden do we require of
repository maintainers to have "smart" repositories?

Repositories
It's pretty easy these days to create a repository that is fairly "smart",
especially if the repository is available on the Internet. Because the language
of the Internet is HTTP then it can be used to provide a smarter repository
experience. Not only that, but it can provide multiple experiences over time
and even at the same time for smooth transitions. By making a well defined and
hopefully simple set of rules how a client will interact with a repository and
determine what resources it wants then a reasonable repository can be defined.

namespace (helps distribute file structure)
name
version
platform [os/arch]
qualifier? classifier?

Pattern:
/root/namespace/name/version/os/arch/product.file

Example:
/pool/com/xeomar/xenon/0.8-20190414034312/any/any/install.pack
/pool/com/xeomar/xenon/0.8-20190414034312/any/any/product.card
/pool/com/xeomar/xenon/0.8-20190414034312/any/any/product.pack


Market - Where to get a list of catalogs
Catalog - Where to get a list of products
Product - The collection of artifacts (many products only have one)
Artifact - A specific set of distributable files

If "stores" are deliniated by "channel" then they only have to have one copy of
the artifact. The metadata regarding the artifact still needs to be available,
but there only needs to be one. And, arguably could be stored by UUID.

write >
commit - store the code in an scm >
build - run through the CI pipeline >
publish - run through the CD pipeline >
check - find published updates in the repo >
download - download the update from the repo >
install - install the update
